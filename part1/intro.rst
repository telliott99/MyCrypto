.. _intro:

###################
Practical Passwords
###################

**Password strategy**

These days it seems that every useful website or service requires a password.  Ideally, passwords should be "strong."  A strong password should require a very large number of attempts before an attacker could guess it successfully.  ``abc123`` and ``pw`` are not strong passwords.

To achieve strength, the best passwords would be a random string of bits.  However, for readability, they are usually represented as strings of printable characters.  Also, to mitigate the possibility that a password has been compromised, policy typically dictates that they change periodically.

Almost no one can remember a constantly changing set of random strings.  One solution is to write the strings to a file and encrypt that, and then remember a single password that unlocks the file.  The master password might be generated from a series of words with additional punctuation and unusual capitalization, something like:

``*I*amthe_greatesT#``

or

``*I*amthe_greatesT#a9b3c6``

I think that having a list of passwords encrypted and stored on disk is a good solution for most situations, e.g. my Amazon account or work email, where for the most part, any damage that might be done with a compromised credential can be reverted.  Advantages include the ability to cut and paste, and cloud storage available to multiple devices.  When combined with challenge-response via smartphone it is quite robust.  

On the other hand, one could rely on physical possession of a password on a sheet of paper, entering it at the keyboard for each use.  This is my approach for the most sensitive passwords, such as banking site passwords.

Security is ultimately a relative judgement.  If the NSA is interested in you, it will be very difficult to keep your secrets.

Here is a simple Python script to generate passwords:

.. sourcecode:: python

    import random
    random.seed(153)
    L1 = list('abcdefghijklmnopqrstuvwxyz')
    L2 = list('0123456789')
    L = [c + d for c in L1 for d in L2]
    N = 10
    pL = [random.choice(L) for i in range(N)]
    print ''.join(pL)
    
Test it:

>>> python pwgen.py
z8b9g7w1x2o7p5v8z3x0
>>>

To generate passwords which are actually random, comment out the second line.  Modify the script to accept the length as an argument on the command line, or just edit the value of *N*.  If the password must be typed rather than copy-pasted, offset the groups so it's easier to read:

.. sourcecode:: python

    sep = ' '
    print sep.join(pL)

>>> python pwgen.py
z8 b9 g7 w1 x2 o7 p5 v8 z3 x0
>>>

**Password complexity**

You've probably seen sites that require you to pick characters from certain sets, for example, including at least one digit, or one punctuation character.  These rules are misguided.  The reason is that the number of permutations *P* generated by a randomization method depends on the size of character set *SZ* and the length of the password *n* in the following way:

.. math::

    P = SZ^n 

*n* is much more important than *SZ*.  Taking logarithms

    log P = n(log SZ)

We see the issue:  *P* goes linearly with *SZ* but exponentially with *n*.  *SZ* doesn't matter (or at least not as much as *n* does).

As an example, a character set of *SZ* equal to 32 (lowercase English alphabet plus the digits 1-6) gives a length 10 password set with the number of permutations equal to 

.. math::

    P = 32^{10} = (2^5)^{10} = 2^{50}
    
If we increase the size of the character set to 64 (base64-encoding) we get

.. math::

    P = 64^{10} = (2^{6})^{10} = 2^{60}

permutations, an increase of a factor of :math:`2^{10}`.  Doubling the size the character set doubles the number of permutations for each character.

On the other hand, retaining the smaller character set but increasing the length by just two gives exactly the same number of permutations.  

.. math::

    P = 32^{12} = (2^{5})^{12} = 2^{60}
    
We can overcome the deficiency of a small character set by a slight increase in length.  For that matter, we could decrease the character set to 8 tokens and increase the length from 10 to 20 and still have the same complexity.

.. math::

    P = 8^{16} = (2^{3})^{20} = 2^{60}

Our primary purpose in restricting the character set is to make it easy to enter passwords by hand.  I could note that the letters and digits are on separate screens on my iPhone, so it would make sense to restrict the character set to just the 26 lowercase characters.  On the other hand, I am so old-fashioned that I rarely enter passwords on my phone.

In the example given above, we have a set of elements containing pairs of characters with a letter followed by a digit, like ``z5``, and the size of the set is 260.  A password of length 20 total characters like ``z8b9g7w1x2o7p5v8z3x0`` has a complexity

>>> 260**10
1411670956533760000000000L

This compares with a password made from single characters randomly chosen from the combined set of letters plus digits and of the same total length

>>> 36**20
13367494538843734067838845976576L

In the latter case, the positions are all independent and the number of permutations is greater by a factor of nearly 10 million.  But we can easily make up for that by a modest increase in password length.  Increasing the length to 13 pairs (26 total characters) gives a permutation space that is twice as large as 20 total characters from the 36 character set.

>>> 1.0 * 260**13 / 36**20
1.8561091354807857

The smaller the character set, the easier it is to type.  Password length is everything.  That is why I prefer the approach shown above for typed passwords.  If there is no need to type, something like this suffices from the command line:

.. sourcecode:: bash

    > openssl rand 12 -base64
    esDld/a+nVvLV5he

Perhaps even better

.. sourcecode:: bash

    > openssl rand 12 -hex
    ba46fc688334fd6fcb113e04

We use the utility ``openssl`` to generate 12 random bytes and then convert the result to base64 or hexadecimal.

**autocomplete="on"**

As an aside, some websites use a form element that instructs the browser not to allow the OS to remember your passwords.  It looks like this:

.. sourcecode:: bash

    <input class="login" type="text" value="" 
    size="20"  autocomplete="off">
    
This is easy to turn off:

http://telliott99.blogspot.com/2010/12/turn-autocompleteon.html

This is not just annoying, it's wrong.  Requiring users to type in their passwords each time is a strong incentive to use weak passwords.  That's bad.  

Of course there is an alternative risk, that the user will somehow "save" his password in an internet cafe, or forget to logoff when done.  That is to me a lesser a problem, and if it is to use, well don't turn off **autocomplete="off"**.